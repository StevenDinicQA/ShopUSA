'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const getBodyAsString = body => {
  let str;

  if (typeof body === "string") {
    str = body;
  } else {
    const decoder = new TextDecoder();
    str = decoder.decode(body);
  }

  return str;
};

const getBoundary = headers => {
  const contentType = headers["content-type"];
  const boundaryMatch = contentType.match(/boundary=([\w-]+)/);
  return boundaryMatch && boundaryMatch[1];
};

const fileFieldParser = part => {
  // eslint-disable-next-line no-useless-escape
  const fileNameMatch = part.match(/name="([\w-_\[\]]+)"; filename="([\w\-_.]+)"/m);
  return fileNameMatch ? [fileNameMatch[1], fileNameMatch[2]] : null;
};

//doesnt support dotsForObjectNotation (object-to-formdata)
const genericFieldParser = part => {
  let name, value;
  const fieldMatch = part.match(/; name="([\w-_.]+)((\[[\w-_]+])*)/);

  if (fieldMatch) {
    name = fieldMatch[1];
    value = part.split(`\r\n`).slice(3, -1).join("");
  }

  return name ? [name, value, fieldMatch[2]] : null;
};

/* istanbul ignore file */
const parsers = [fileFieldParser, genericFieldParser];

const resultAppender = (result, name, value, path) => {
  if (!path) {
    result[name] = value;
  } else {
    let parent = result;
    [`[${name}]`].concat(path.match(/\[[\w-_]+]/g)).forEach((pathPart, index, allPaths) => {
      var _allPaths;

      const cleanName = pathPart.replace(/[\][]/g, ""); //look ahead to determine the type of the "child"

      const cleanChild = (_allPaths = allPaths[index + 1]) === null || _allPaths === void 0 ? void 0 : _allPaths.replace(/[\][]/g, "");
      const isChildArray = !isNaN(cleanChild);

      if (!parent[cleanName]) {
        parent[cleanName] = isChildArray ? [] : {};
      }

      if (allPaths.length - index === 1) {
        parent[cleanName] = value;
      } else {
        parent = parent[cleanName];
      }
    });
  }

  return result;
};

const parse = (part, parsers) => {
  let parsed = null,
      index = 0;

  while (!parsed && index < parsers.length) {
    parsed = parsers[index](part);
    index += 1;
  }

  return parsed || [];
};

const getFormDataFromRequest = (body, boundary) => {
  const decoded = getBodyAsString(body);
  const parts = decoded.split(boundary);
  return parts.reduce((res, p) => {
    const [name, value, path] = parse(p, parsers);

    if (name) {
      res = resultAppender(res, name, value, path);
    }

    return res;
  }, {});
};

const interceptFormData = request => {
  const {
    body,
    headers
  } = request;
  const boundary = getBoundary(headers);
  return getFormDataFromRequest(body, boundary);
};

/* istanbul ignore file */
Cypress.Commands.add("interceptFormData", {
  prevSubject: true
}, (interception, cb) => {
  cy.wrap(interceptFormData(interception.request)).then(cb).then(() => interception);
});

exports.interceptFormData = interceptFormData;
